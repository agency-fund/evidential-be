import base64
import json
import os
from typing import Optional

from loguru import logger

from xngin.xsecrets import (
    aws_provider,
    gcp_provider,
    local_provider,
    noop_provider,
)
from xngin.xsecrets.constants import (
    ENV_XNGIN_SECRETS_BACKEND,
    SERIALIZED_ENCRYPTED_VALUE_PREFIX,
)
from xngin.xsecrets.exceptions import InvalidSecretStoreConfigurationError
from xngin.xsecrets.provider import Registry

_SERVICE: Optional["SecretService"] = None


def setup():
    """Configures a secrets service according to environment variables."""
    global _SERVICE

    registry = Registry()

    aws_provider.initialize(registry)
    gcp_provider.initialize(registry)
    local_provider.initialize(registry)

    registered = registry.get_providers()

    backend_spec = os.environ.get(ENV_XNGIN_SECRETS_BACKEND, noop_provider.NAME)
    if backend_spec == noop_provider.NAME:
        logger.warning(
            f"Secrets: Encryption is disabled because {ENV_XNGIN_SECRETS_BACKEND} is unset "
            f"or set to {noop_provider.NAME}."
        )
        noop_provider.initialize(registry)
        backend_spec = noop_provider.NAME
    elif backend_spec not in registered:
        raise InvalidSecretStoreConfigurationError(
            f"Requested backend '{backend_spec}' is not registered (available: {', '.join(registered)})"
        )

    logger.info(
        f"Secrets: Using '{backend_spec}' for encryption (available: {', '.join(registered)})"
    )
    _SERVICE = SecretService(registry, backend_spec)


def is_encrypted(value: str) -> bool:
    """Returns True when the value resembles a ciphertext generated by this module."""
    return value.startswith(SERIALIZED_ENCRYPTED_VALUE_PREFIX)


def _serialize(backend: str, ciphertext: bytes) -> str:
    """Serializes the encrypted secret as a string."""
    serialized = json.dumps(
        [
            [backend, base64.standard_b64encode(ciphertext).decode()],
        ],
        separators=(",", ":"),
    )
    return f"{SERIALIZED_ENCRYPTED_VALUE_PREFIX}{serialized}"


def _deserialize(serialized: str) -> tuple[str, bytes]:
    """Deserializes a string encoded with _serialize into a provider name and ciphertext."""
    prefix = SERIALIZED_ENCRYPTED_VALUE_PREFIX
    if len(serialized) < len(prefix) or not serialized.startswith(prefix):
        raise ValueError(f"String must start with '{prefix}' prefix")
    start_pos = len(prefix)
    try:
        arr = json.loads(serialized[start_pos:])
    except json.decoder.JSONDecodeError as exc:
        raise ValueError(
            "Serialized encrypted data does not match expected format."
        ) from exc
    if not isinstance(arr, list) or not (
        len(arr) > 0
        and isinstance(arr[0], list)
        and len(arr[0]) == 2
        and all(isinstance(v, str) for v in arr[0])
    ):
        raise ValueError("Serialized encrypted data does not match expected format.")
    kms, ciphertext = arr[0][0], arr[0][1]
    return kms, base64.standard_b64decode(ciphertext)


class SecretService:
    """Implements methods for handling encryption and decryption using providers from a Registry."""

    def __init__(self, registry: Registry, encryption_provider: str):
        """Create a SecretService using the specified registry and encryption provider."""
        self.registry = registry
        self.encryption_provider = self.registry.get(encryption_provider)

    def encrypt(self, pt: str, aad: str) -> str:
        """Encrypts a value with the default encryption provider.

        Raises ValueError if plaintext already resembles encrypted text.
        """
        if is_encrypted(pt):
            raise ValueError("The value being encrypted is already encrypted.")
        return _serialize(
            backend=self.encryption_provider.name(),
            ciphertext=self.encryption_provider.encrypt(
                pt.encode("utf-8"), aad.encode("utf-8")
            ),
        )

    def decrypt(self, ct: str, aad: str) -> str:
        """Decrypts a value with any registered encryption provider.

        If the ciphertext does not have the expected prefix, we assume it is not actually encrypted, and return it
        as-is. This allows backwards compatibility with values persisted prior to the introduction of encryption.
        """
        if not is_encrypted(ct):
            return ct
        kms, ciphertext = _deserialize(ct)
        provider = self.registry.get(kms)
        decrypted: bytes = provider.decrypt(ciphertext, aad.encode("utf-8"))
        return decrypted.decode("utf-8")


def get_symmetric() -> SecretService:
    if not _SERVICE:
        raise InvalidSecretStoreConfigurationError(
            "setup() must be called before encryption operations"
        )
    return _SERVICE
