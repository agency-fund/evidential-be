import inspect
import logging
import sys

from loguru import logger
from sqlalchemy import log as sqlalchemy_log

from xngin.apiserver import flags

# Configure the Google SDK to log to loguru. Google's Python logging practices are poorly documented but manual
# inspection shows that they generally put loggers in the `google` namespace. There are also some old docs:
# https://cloud.google.com/python/docs/reference/google-cloud-developerconnect/latest
logging.getLogger("google").setLevel(
    logging.INFO
)  # Tip: set to WARN to log HTTP interactions with BigQuery APIs.
logging.getLogger("google").propagate = True

# Only show warnings from SQLAlchemy pool classes. DEBUG will log on every connection open/close.
logging.getLogger("sqlalchemy.pool").setLevel(logging.WARN)

# sqlalchemy.orm: at INFO, this will log its internal model of the entity metadata.
logging.getLogger("sqlalchemy.orm").setLevel(logging.WARN)

# sqlalchemy.dialects.postgresql will log Postgres wire protocol NOTICE messages at INFO level.
logging.getLogger("sqlalchemy.dialects.postgresql").setLevel(logging.INFO)

# Conditionally enable the logging of SQL generated by SQLAlchemy for customer warehouses.
# Tip: set this to DEBUG to see details on table metadata such as column name and types.
logging.getLogger("sqlalchemy.engine.Engine.xngin_dwh").setLevel(
    logging.INFO if flags.LOG_SQL else logging.WARN
)

# Conditionally enable the logging of SQL generated by SQLAlchemy for the xngin app database.
logging.getLogger("sqlalchemy.engine.Engine.xngin_app").setLevel(
    logging.INFO if flags.LOG_SQL_APP_DB else logging.WARN
)

# If ECHO_SQL is True, we'll get duplicate log lines. ECHO_SQL is meant for debugging and is incompatible with
# explicitly configured loggers.
if flags.ECHO_SQL or flags.ECHO_SQL_APP_DB:
    print("----- DISABLING SQLALCHEMY LOGGER DEFAULT HANDLER ----- ")
    sqlalchemy_log._add_default_handler = lambda logger: None


def dlog(msg: str):
    if flags.DEBUG_LOGGING:
        print("customlogging: " + msg)


def setup():
    dlog("Configuring custom logging")

    for handler in logging.root.handlers[:]:
        dlog(f"Removing root handler: {handler}")
        logging.root.removeHandler(handler)

    class InterceptHandler(logging.Handler):
        def emit(self, record: logging.LogRecord) -> None:
            # Get corresponding Loguru level if it exists.
            try:
                level: str | int = logger.level(record.levelname).name
            except ValueError:
                level = record.levelno

            # Find caller from where originated the logged message.
            frame, depth = inspect.currentframe(), 0
            while frame:
                filename = frame.f_code.co_filename
                is_logging = filename == logging.__file__
                is_frozen = "importlib" in filename and "_bootstrap" in filename
                if depth > 0 and not (is_logging or is_frozen):
                    break
                frame = frame.f_back
                depth += 1

            logger.opt(depth=depth, exception=record.exc_info).log(
                level, record.getMessage()
            )

    logging.basicConfig(handlers=[InterceptHandler()], level=logging.NOTSET, force=True)

    loggers = sorted([
        logging.getLogger(name).name for name in logging.root.manager.loggerDict
    ])
    for name in loggers:
        existing_logger = logging.getLogger(name)
        dlog(f"Forcing propagation on {name} (was {existing_logger.handlers})")
        existing_logger.handlers = []
        existing_logger.propagate = True

    # Silence some unnecessarily noisy loggers.
    logger.disable("httpcore")
    logger.disable("httpx")
    logger.disable("watchfiles.main")
    logger.disable("sentry_sdk.integrations.logging")

    # Development environments don't need the date or full level names; this makes it easier to read in terminal output.
    # When this flag isn't set, loguru's default more verbose format is used by default.
    if flags.FRIENDLY_DEV_LOGGING:
        logger.remove()
        logger.add(
            sys.stdout,
            format="<green>{time:HH:mm:ss}</green> | "
            "<level>{level.icon}</level> | "
            "<cyan>{name}</cyan>:<cyan>{function}</cyan>:<cyan>{line}</cyan> - {extra} <level>{message}</level>",
        )
