"""Implements a basic Google OIDC RP."""

import asyncio
import logging
import os
from contextlib import asynccontextmanager
from typing import Annotated

import httpx
from fastapi import APIRouter, Query, FastAPI, HTTPException
from fastapi.security import OpenIdConnect
from pydantic import BaseModel, Field
from fastapi.responses import FileResponse
from xngin.apiserver import constants

ENV_GOOGLE_OIDC_CLIENT_ID = "GOOGLE_OIDC_CLIENT_ID"
ENV_GOOGLE_OIDC_CLIENT_SECRET = "GOOGLE_OIDC_CLIENT_SECRET"
ENV_GOOGLE_OIDC_REDIRECT_URI = "GOOGLE_OIDC_REDIRECT_URI"

CLIENT_ID = os.environ.get(ENV_GOOGLE_OIDC_CLIENT_ID)
CLIENT_SECRET = os.environ.get(ENV_GOOGLE_OIDC_CLIENT_SECRET)
GOOGLE_DISCOVERY_URL = "https://accounts.google.com/.well-known/openid-configuration"
DEFAULT_REDIRECT_URI = f"http://localhost:8000{constants.API_PREFIX_V1}/a/oidc"  # default value should match OIDC_BASE_URL in pkcetest.html
REDIRECT_URI = os.environ.get(
    ENV_GOOGLE_OIDC_REDIRECT_URI, DEFAULT_REDIRECT_URI
)  # used for testing UI only
oidc_google = OpenIdConnect(openIdConnectUrl=GOOGLE_DISCOVERY_URL)

logger = logging.getLogger(__name__)


class OidcMisconfiguredError(Exception):
    pass


def is_enabled():
    """Feature flag: Returns true iff OIDC is enabled."""
    enabled = os.environ.get("ENABLE_OIDC", "").lower() in ("true", "1")
    if enabled:
        if not os.environ.get(ENV_GOOGLE_OIDC_CLIENT_ID):
            raise OidcMisconfiguredError(
                f"{ENV_GOOGLE_OIDC_CLIENT_ID} environment variable is not set."
            )
        if not os.environ.get(ENV_GOOGLE_OIDC_CLIENT_SECRET):
            logger.warning(
                f"{ENV_GOOGLE_OIDC_CLIENT_SECRET} environment variable is not set."
            )
    return enabled


# TODO: refresh these occasionally
google_jwks = None
google_config = None


@asynccontextmanager
async def lifespan(_app: FastAPI):
    await asyncio.gather(get_google_jwks())
    yield


router = APIRouter(
    lifespan=lifespan,
    prefix="/a/oidc",
)


async def get_google_configuration():
    """Fetch and cache Google's OpenID configuration"""
    global google_config
    if google_config is None:
        async with httpx.AsyncClient() as client:
            response = await client.get(GOOGLE_DISCOVERY_URL)
            response.raise_for_status()
            google_config = response.json()
    return google_config


async def get_google_jwks():
    """Fetch and cache Google's JWKS"""
    global google_jwks
    if google_jwks is None:
        config = await get_google_configuration()
        async with httpx.AsyncClient() as client:
            response = await client.get(config["jwks_uri"])
            response.raise_for_status()
            google_jwks = response.json()
    return google_jwks


# TODO: remove this once integration is confirmed to work
@router.get("/")
def index():
    return FileResponse("static/pkcetest.html")


class CallbackResponse(BaseModel):
    """The credentials returned to the SPA."""

    id_token: Annotated[
        str,
        Field(
            ...,
            description="The ID token as generated by Google. Represents a successful authentication.",
        ),
    ]


@router.get("/callback")
async def auth_callback(
    code: Annotated[str, Query(...)],
    code_verifier: Annotated[
        str, Query(min_length=43, max_length=128, pattern=r"^[A-Za-z0-9._~-]+$")
    ],
) -> CallbackResponse:
    """OAuth callback endpoint that exchanges the authorization code for tokens, and returns the id_token to the client.

    Only relevant for PKCE.
    """
    config = await get_google_configuration()
    async with httpx.AsyncClient() as client:
        token_endpoint = config["token_endpoint"]
        token_response = await client.post(
            token_endpoint,
            data={
                "client_id": CLIENT_ID,
                # client_secret is not strictly required by PKCE spec but Google requires it.
                "client_secret": CLIENT_SECRET,
                "code": code,
                "code_verifier": code_verifier,
                "redirect_uri": REDIRECT_URI,
                "grant_type": "authorization_code",
            },
        )
        logger.info(f"token exchange response = {token_response.content}")
        token_response.raise_for_status()
        response = token_response.json()
        if type(response) is not dict or response.get("id_token") is None:
            raise HTTPException(
                status_code=500, detail=f"Unexpected response from {token_endpoint}"
            )
        return CallbackResponse(id_token=response.get("id_token"))
